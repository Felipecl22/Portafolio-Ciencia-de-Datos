# -*- coding: utf-8 -*-
"""Funciones.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/14Rd7MCkhsk30UtwO46snZw5cPJMDUYKn
"""

import math
import numpy as np

# Crear función:
# Empezar con def y terminar con return.

######################################################################################
def multiplicacion(a, b):
    return a * b
usar_formula = multiplicacion(2,2)
print(usar_formula)
######################################################################################
def area_circulo (radio, pi): # Asignamos dos parametros a la formula.
    area = pi * (radio**2)
    return area

radio = 5
pi = 3.14159
area_calculada = area_circulo(radio, pi)
print("El área del círculo es:", area_calculada)
######################################################################################
def encontrar_divisores(numero):
    divisores = []  # Creamos una lista para almacenar los divisores.
    for i in range(1, numero + 1): # numero + 1 para incluir el número.
        if numero % i == 0:
            divisores.append(i)  # Agregamos i a la lista si es divisor de numero.
    return divisores  # Devolvemos la lista de divisores al final de la función.

numero = 152
divisores = encontrar_divisores(numero)
print("Los divisores de ", numero, "Son: ", divisores)

######################################################################################
# Lambda
# En Python, lambda es una palabra clave que se utiliza para definir funciones anónimas, es decir,
# funciones pequeñas y simples que no necesitan un nombre definido formalmente como las funciones
# creadas mediante la declaración def.

# Syntax:
# lambda argumentos: expresion

# lambda es la palabra clave que indica que estamos creando una función anónima.
# argumentos son los argumentos de la función separados por comas. Pueden ser cero o más argumentos, y se pueden utilizar en la expresión de la función.
# expresion es la expresión que se evalúa y devuelve como resultado de la función.

potencia = lambda  x, y: x ** y
print(potencia(2,2))

# Usando x como argumento para luego dar el valor.
lista_de_numeros = [1,2,3,4,5,6]
promedio = lambda x: sum(x) / len(x)
promedio(lista_de_numeros)

suma = lambda x: sum(x)
suma(lista_de_numeros)

mediana = lambda x: np.median(x) # Muy tedioso de otra forma, por eso mejor usar numpy para simplificar el código.
mediana(lista_de_numeros)

# Convertir una lista de números a sus cuadrados usando lambda y map
numeros = [1, 2, 3, 4, 5]
cuadrados = list(map(lambda x: x ** 2, numeros))
print(cuadrados)  # Output: [1, 4, 9, 16, 25]

# Función lambda que devuelve el número si es par y su cuadrado si es impar
funcion = lambda x: x if x % 2 == 0 else x ** 2
print(funcion(4))  # Output: 4
print(funcion(5))  # Output: 25

# Ordenar una lista de tuplas por el segundo elemento de cada tupla
tuplas = [(1, 'b'), (3, 'a'), (2, 'c')]
ordenado = sorted(tuplas, key=lambda x: x[1])
print(ordenado)  # Output: [(3, 'a'), (1, 'b'), (2, 'c')]

# Factorial utilizando una función lambda recursiva
factorial = lambda n: 1 if n == 0 else n * factorial(n - 1)
print(factorial(5))  # Output: 120

# Funciones de conversión:

celsius_a_fahrenheit = lambda x: x * 9/5 + 32
celsius_a_kelvin = lambda x: x + 273.15
fahrenheit_a_celsius = lambda x: (x - 32) * 5/9
fahrenheit_a_kelvin = lambda x: (x + 459.67) * 5/9
kelvin_a_celsius = lambda x: x - 273.15
kelvin_a_fahrenheit = lambda x: x * 9/5 - 459.67

# Función de conversión:
def convertir(grados, unidad_entrada, unidad_salida):
    if unidad_entrada == "C":
        if unidad_salida == "F":
            return celsius_a_fahrenheit(grados)
        elif unidad_salida == "K":
            return celsius_a_kelvin(grados)
    elif unidad_entrada == "F":
        if unidad_salida == "C":
            return fahrenheit_a_celsius(grados)
        elif unidad_salida == "K":
            return fahrenheit_a_kelvin(grados)
    elif unidad_entrada == "K":
        if unidad_salida == "C":
            return kelvin_a_celsius(grados)
        elif unidad_salida == "F":
            return kelvin_a_fahrenheit(grados)
    else:
        return "Unidades de temperatura no válidas"